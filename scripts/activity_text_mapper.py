__author__ = 'Ziyue Yang'

import os
import argparse
import re
import sys
import json

from xml.etree import ElementTree


def run(decoded_dir, droidbot_out_dir, output_dir):
    """
    :param request_json_file:
    :param result_json_file:
    :param report_file:
    """
    decoded_dir = os.path.abspath(decoded_dir)
    droidbot_out_dir = os.path.abspath(droidbot_out_dir)
    output_dir = os.path.abspath(output_dir)

    # get package name intersection
    apk_list = os.walk(decoded_dir).next()[1]
    droidbot_out_list = os.walk(droidbot_out_dir).next()[1]

    package_name_list = sorted(list(set(apk_list) & set(droidbot_out_list)))
    activity_text_mapping = {}

    count = 0
    for package_name in package_name_list:
        try:
            activity_text_mapping[package_name] = {}

            # get xml file
            xml_tree = ElementTree.parse("%s/%s/AndroidManifest.xml" % (decoded_dir, package_name))
            xml_activity_list = xml_tree.getroot().find('application').findall('activity')
            activity_name_list = map(lambda x: x.attrib[filter(lambda y: 'name' in y, x.keys())[0]], xml_activity_list)
            # get device states generated by droidbot

            # warning: the activity names in AndroidManifest may has the following 3 cases
            # 1. asdf --> package.asdf
            # 2. .asdf --> package.asdf
            # 3. asdf.asdf --> asdf.asdf
            # however, the foreground-activity-name in droidbot_outs is the case 3 with asdf/.asdf
            #
            device_states = filter(lambda x: '.json' in x, os.walk("%s/%s/device_states" % (droidbot_out_dir, package_name)).next()[2])

            for device_state in device_states:
                with open("%s/%s/device_states/%s" % (droidbot_out_dir, package_name, device_state), 'r') as device_state_file:
                    device_state_json = json.load(device_state_file)
                    current_activity = device_state_json['foreground_activity'].split('/')[-1]

                    if (current_activity in activity_name_list) or \
                       (current_activity[0] == '.' and current_activity[1:] in activity_name_list) or \
                       (''.join(device_state_json['foreground_activity'].split('/')) in activity_name_list):
                        if current_activity not in activity_text_mapping[package_name].keys():
                            activity_text_mapping[package_name][current_activity] = []
                        activity_state = map(
                            lambda x: {"text": x['text'], "rid": x['resource_id'], "class": x['class']},
                            device_state_json['views'])
                        if activity_state not in activity_text_mapping[package_name][current_activity]:
                            activity_text_mapping[package_name][current_activity].append(activity_state)
        except:
            print "%s failed" % package_name
        count += 1
        print "%s/%s" % (str(count), str(len(package_name_list)))

    with open("%s/activity_text_mapping.json" % output_dir, 'w') as output_file:
        json.dump(activity_text_mapping, output_file)


def parse_args():
    """
    parse command line input
    generate activity - text mapping
    given apks (AndroidManifeest.xml) and droidbot testing data.
    """
    parser = argparse.ArgumentParser(description="generate activity - text mapping for functional analysis")
    parser.add_argument("--apks", action="store", dest="decoded_dir",
                        required=True, help="path/to/decoded_dir")
    parser.add_argument("--droidbot_out", action="store", dest="droidbot_out_dir",
                        required=True, help="path/to/droidbot_out")
    parser.add_argument("-o", action="store", dest="output_dir",
                        required=True, help="path/to/output.json")

    options = parser.parse_args()
    # print options
    return options


def main():
    """
    the main function
    """
    opts = parse_args()
    run(opts.decoded_dir, opts.droidbot_out_dir, opts.output_dir)

    return


if __name__ == "__main__":
    main()
