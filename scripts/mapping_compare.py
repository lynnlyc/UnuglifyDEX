__author__ = 'yuanchun'

import os
import argparse
import re


RE_CLASS_LINE = re.compile('([^\ ]+) -> ([^\ ]+):\n')
RE_METHOD_LINE = re.compile('([^\ ]+)\ ([^\ ]+)\((.*)\) -> ([^\ ]+)\n')
RE_FIELD_LINE = re.compile('([^\ ]+)\ ([^\ \)]+) -> ([^\ ]+)\n')


class ObfuscationMapping(object):
    """
    describe a mapping.txt generated by proguard or UnuglifyDEX
    """
    def __init__(self, mapping_file):
        self.lines = open(mapping_file).readlines()
        self.package_mapping = {}
        self.class_mapping = {}
        self.class_origin2obfus = {}
        self._build_package_class_mapping()
        self.field_mapping = {}
        self.method_mapping = {}
        self._build_field_method_mapping()
        self.mapping = {}
        self.mapping.update(self.package_mapping)
        self.mapping.update(self.class_mapping)
        self.mapping.update(self.field_mapping)
        self.mapping.update(self.method_mapping)

    def dump(self, out_file):
        for key in sorted(self.mapping):
            out_file.write("%s -> %s\n" % (key, self.mapping[key]))

    def dump_report(self, file_name):
        out_file = open(file_name, "w")
        self.dump(out_file)
        out_file.close()

    def _build_package_class_mapping(self):
        for line in self.lines:
            m = RE_CLASS_LINE.search(line)
            if not m:
                continue
            class_origin, class_obfus = m.group(1), m.group(2)
            package_origin, package_obfus = \
                ".".join(class_origin.split('.')[:-1]), ".".join(class_obfus.split('.')[:-1])
            self._add_class_map(class_origin, class_obfus)
            self._add_package_map(package_origin, package_obfus)

    def _build_field_method_mapping(self):
        current_cls_id = None
        for line in self.lines:
            m = RE_CLASS_LINE.search(line)
            if m:
                current_cls_id = m.group(2)
                continue
            m = RE_FIELD_LINE.search(line)
            if m:
                assert current_cls_id is not None
                field_type, origin_name, obfus_name = \
                    m.group(1).strip(), m.group(2).strip(), m.group(3).strip()
                if origin_name == obfus_name:
                    continue
                field_id = self._get_unique_field_id(current_cls_id, obfus_name, field_type)
                assert field_id not in self.field_mapping.keys()
                self.field_mapping[field_id] = origin_name
                continue
            m = RE_METHOD_LINE.search(line)
            if m:
                assert current_cls_id is not None
                ret_type, origin_name, param_types, obfus_name = \
                    m.group(1).strip(), m.group(2).strip(), m.group(3).strip(), m.group(4).strip()
                if origin_name == obfus_name:
                    continue
                method_id = self._get_unique_method_id(current_cls_id, obfus_name, param_types)
                assert method_id not in self.method_mapping.keys()
                self.method_mapping[method_id] = origin_name

    def _add_class_map(self, class_origin, class_obfus):
        if class_origin == class_obfus:
            return
        self.class_mapping[class_obfus] = class_origin.split('.')[-1]
        self.class_origin2obfus[class_origin] = class_obfus

    def _add_package_map(self, package_origin, package_obfus):
        if package_origin == package_obfus:
            return
        self.package_mapping[package_obfus] = package_origin.split('.')[-1]

    def _get_unique_field_id(self, class_id, field_name, field_type):
        type_id = self._get_unique_class_id(field_type)
        return "%s;->%s:%s" % (class_id, field_name, type_id)

    def _get_unique_method_id(self, class_id, method_name, param_types):
        param_ids = []
        for param_type in param_types.split(','):
            param_ids.append(self._get_unique_class_id(param_type))
        return "%s;->%s(%s)" % (class_id, method_name, ",".join(param_ids))

    def _get_unique_class_id(self, class_name):
        if class_name in self.class_origin2obfus.keys():
            return self.class_origin2obfus[class_name]
        else:
            return class_name


def run(proguard_mapping_file, predict_mapping_file, report_dir):

    """

    :param proguard_mapping_file:
    :param predict_mapping_file:
    :param report_dir:
    """

    proguard_mapping_file = os.path.abspath(proguard_mapping_file)
    predict_mapping_file = os.path.abspath(predict_mapping_file)
    report_dir = os.path.abspath(report_dir)

    proguard = ObfuscationMapping(proguard_mapping_file)
    proguard.dump_report(report_dir + "/proguard_result.txt")

    predict = ObfuscationMapping(predict_mapping_file)
    predict.dump_report(report_dir + "/predict_result.txt")

    output_template = "Proguard obfuscated %d items, UnuglifyDEX deobfuscated %d items.\n" \
                      "TP: %d, Recall: %f, Precision: %f\n"

    print "For packages:\n" + output_template % compare_two_dict(proguard.package_mapping, predict.package_mapping)
    print "For classes:\n" + output_template % compare_two_dict(proguard.class_mapping, predict.class_mapping)
    print "For fields:\n" + output_template % compare_two_dict(proguard.field_mapping, predict.field_mapping)
    print "For methods:\n" + output_template % compare_two_dict(proguard.method_mapping, predict.method_mapping)
    print "In total:\n" + output_template % compare_two_dict(proguard.mapping, predict.mapping)


def compare_two_dict(dict_a, dict_b):
    set_a = set(dict_a.items())
    set_b = set(dict_b.items())
    set_tp = set_a & set_b
    return (len(set_a), len(set_b), len(set_tp),
            safe_divide(len(set_tp), len(set_a)), safe_divide(len(set_tp), len(set_b)))


def safe_divide(a, b):
    if b <= 0:
        return 1
    return float(a) / b


def parse_args():
    """
    parse command line input
    generate options including input proguard-generated mappings and predict mappings
    """
    parser = argparse.ArgumentParser(description="comparing proguard-generated and predict mappings")
    parser.add_argument("--proguard", action="store", dest="proguard_mapping_file",
                        required=True, help="path to proguard-generated mapping.txt")
    parser.add_argument("--predict", action="store", dest="predict_mapping_file",
                        required=True, help="path to predict mapping.txt")
    parser.add_argument("-o", action="store", dest="report_dir",
                        required=True, help="directory of report files")

    options = parser.parse_args()
    # print options
    return options


def main():
    """
    the main function
    """
    opts = parse_args()
    run(opts.proguard_mapping_file, opts.predict_mapping_file, opts.report_dir)

    return


if __name__ == "__main__":
    main()
