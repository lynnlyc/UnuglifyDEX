__author__ = 'yuanchun'

import os
import argparse
import re
import sys
import json


RE_CLASS_LINE = re.compile('([^\ ]+) -> ([^\ ]+):\n')
RE_METHOD_LINE = re.compile('([^\ ]+)\ ([^\ ]+)\((.*)\) -> ([^\ ]+)\n')
RE_FIELD_LINE = re.compile('([^\ ]+)\ ([^\ \)]+) -> ([^\ ]+)\n')


class DetailedMapping(object):
    """
    describe a mapping.txt generated by proguard or UnuglifyDEX
    """
    def __init__(self, mapping_file):
        self.lines = open(mapping_file).readlines()
        self.class_origin2new = {}
        self._build_package_class_mapping()
        # print self.class_origin2new
        self.field_origin2new = {}
        self.method_origin2new = {}
        self._build_field_method_mapping()
        self.origin2new = {}
        self.origin2new.update(self.class_origin2new)
        self.origin2new.update(self.field_origin2new)
        self.origin2new.update(self.method_origin2new)

    def dump_report(self, file_name):
        out_file = open(file_name, "w")
        json.dump(self.origin2new, out_file, indent=2)
        out_file.close()

    def _build_package_class_mapping(self):
        for line in self.lines:
            m = RE_CLASS_LINE.search(line)
            if not m:
                continue
            origin_cls_sig, new_cls_sig = m.group(1), m.group(2)
            if origin_cls_sig == new_cls_sig:
                continue
            self.class_origin2new[origin_cls_sig] = new_cls_sig

    def _build_field_method_mapping(self):
        origin_cls_sig = None
        new_cls_sig = None
        for line in self.lines:
            m = RE_CLASS_LINE.search(line)
            if m:
                origin_cls_sig = m.group(1)
                new_cls_sig = m.group(2)
                continue
            m = RE_FIELD_LINE.search(line)
            if m:
                # assert new_cls_sig is not None
                origin_field_type, origin_name, new_name = \
                    m.group(1).strip(), m.group(2).strip(), m.group(3).strip()
                if origin_name == new_name:
                    continue
                new_field_type = self._get_new_class_sig(origin_field_type)
                origin_field_sig = "<%s: %s %s>" % (origin_cls_sig, origin_field_type, origin_name)
                new_field_sig = "<%s: %s %s>" % (new_cls_sig, new_field_type, new_name)
                self.field_origin2new[origin_field_sig] = new_field_sig
                continue
            m = RE_METHOD_LINE.search(line)
            if m:
                # assert new_cls_sig is not None
                origin_ret_type, origin_name, origin_param_types, new_name = \
                    m.group(1).strip(), m.group(2).strip(), m.group(3).strip(), m.group(4).strip()
                if origin_name == new_name:
                    continue
                new_ret_type = self._get_new_class_sig(origin_ret_type)
                new_param_types = self._get_new_param_types(origin_param_types)
                origin_method_sig = "<%s: %s %s(%s)>" % (origin_cls_sig, origin_ret_type, origin_name, origin_param_types)
                new_method_sig = "<%s: %s %s(%s)>" % (new_cls_sig, new_ret_type, new_name, new_param_types)
                # assert method_id not in self.method_mapping.keys()
                self.method_origin2new[origin_method_sig] = new_method_sig

    def _get_new_param_types(self, param_types):
        new_param_types = []
        for param_type in param_types.split(','):
            new_param_types.append(self._get_new_class_sig(param_type))
        return ",".join(new_param_types)

    def _get_new_class_sig(self, class_name):
        if class_name in self.class_origin2new.keys():
            return self.class_origin2new[class_name]
        else:
            return class_name


def run(proguard_mapping_file, report_file):

    """

    :param proguard_mapping_file:
    :param report_file:
    """

    proguard = DetailedMapping(proguard_mapping_file)
    proguard.dump_report(report_file)


def safe_get(data_dict, key):
    if key in data_dict.keys():
        return data_dict[key]
    return "?"


def safe_divide(a, b):
    if b <= 0:
        return 1
    return float(a) / b


def parse_args():
    """
    parse command line input
    generate options including input proguard-generated mappings and predict mappings
    """
    parser = argparse.ArgumentParser(description="comparing proguard-generated and predict mappings")
    parser.add_argument("-i", action="store", dest="mapping_file",
                        required=True, help="path to proguard-generated mapping.txt")
    parser.add_argument("-o", action="store", dest="new_mapping_file",
                        required=True, help="path to output converted mapping file")

    options = parser.parse_args()
    # print options
    return options


def main():
    """
    the main function
    """
    opts = parse_args()
    run(opts.mapping_file, opts.new_mapping_file)

    return


if __name__ == "__main__":
    main()
